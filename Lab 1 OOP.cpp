#include <iostream> 
#include <cmath>
#include "header.h"

using namespace std;
// Radomanova Sofiia, 10.Поле first - координата X, а second – координата Y точки на площині.
//Реалізувати метод distance(), що знаходить відстань від початку координат до
//точки з координатами(x; y).





void Function(Point p) 
{
	cout << "Значення змінної count після використання конструктора копіювання:" << Point::get_count() << '\n';
	// Викликається конструктор копіювання для аргумента p
}

int Point::count = 0; // Ініціалізація статичної змінної класу


int main()
{

	//cout << "Значення змінної count до створення екземплярів класу:" << Point::get_count() << '\n';
	// 
		//Завдання 1. Створення класу
		/*З головної функції створити два екземпляри розробленого класу,
	застосувавши різні форми конструкторів, вивести значення полів на екран,
		продемонструвати роботу методу відповідно до варіанту завдання.*/

	Point point1;
	//cout << "Значення змінної count після створення екземпляру класу:" << Point::get_count() << '\n';
	//point1.print(); //виклик метода прінт (використання конструктора без параметрів)
	cout << point1 << "\n";

	Point point2(2, 17);
	//cout << "Значення змінної count пісоя створення екземпляру класу:" << Point::get_count() << '\n';
	//point2.print(); //виклик метода прінт (використання конструктора з параметрами)
	cout << point2 << "\n";
	cout << '\n';


		//демонстрація роботи конструктора копіювання
	//Point point3 = point2; // Явне копіювання об'єкта
	//cout << point3 <<'\t' << point2 << '\n';
	//Point point4(point2); //Ініціалізація об'єкта через список ініціалізаторів
	//Function(point3); // Передача об'єкта в функцію за значенням
	

		//демонстрація роботи сеттеру
	cout << "Робота сеттеру для point 1: ";
	point1.setX(7);
	point1.setY(10);
	//point1.print(); 
	cout << point1 << "\n";
		
		//демонстрація роботи геттеру
	cout << "Робота геттеру для point 2: ";
	point2.getX();
	point2.getY();
	cout << point2 << "\n";
	cout << "\n";
		/*3. В кінці програми явно додати виклик деструктора хоча б для одного
		екземпляру класу.Чи буде викликатися деструктор для іншого екземпляру
		(відповідь обгрунтуйте) ?*/
	
		/*4. Описати та створити масив з екземплярів цього класу, вивести значення
		полів на екран.Дайте відповідь на запитання : який конструктор було
		викликано для елементів масиву ?*/
		//створення масиву об'єктів класу Point
	//Point points_1[4] = { Point(1, 1), Point(9, 3), Point(5, 8), Point(12, 2) };
	//cout << "Значення змінної count після створення екземплярів класу в масиві:" << Point::get_count() << '\n';
	//for (int i = 0; i < 4; i++)
	//{
	//	cout << points_1[i];
	//}


		/*5. Для елементів масиву передбачити введення даних, а також виведення
		результатів роботи методу відповідно до варіанту завдання.*/
	int number;
	cout << "\nВведіть кількість об'єктів класу: ";
	cin >> number;
	cout << '\n';
	Point* points = new Point[number];
	//cout << "Значення змінної count після створення екземплярів класу в векторі:" << Point::get_count() << '\n';

	for (int i = 0; i < number; i++)
	{
		cout << "Введіть координату Х " << i+1 << " об'єкту:";
		int x;
		cin >> x;
		points[i].setX(x);

		cout << "Введіть координату Y " << i+1 << " об'єкту:";
		int y;
		cin >> y;
		points[i].setY(y);
	
		
	}

	for (int i = 0; i < number; i++)
	{
		cout << points[i] << '\n';
		cout << "Дистанція до точки: " << points[i].distance() << '\n';
	}


	/*cout << "Об'єкт + Об'єкт: " << points[0] + points[1] << '\n';
	cout << "Введіть число для додавання: ";
	double numberforadding;
	cin >> numberforadding;
	cout << "Об'єкт + число: " << points[0] + numberforadding << '\n';
	cout << "Число + об'єкт: " << numberforadding + points[0] << '\n';
	cout << "Префіксна форма (++point): " << ++points[0];
	Point temp = points[0]++;
	cout << "Постфіксна форма (point++): " << temp << '\n';*/


	 //cout << "Значення змінної count перед викликом деструкторів:" << Point::get_count() << '\n';

	delete[] points;
	// point1.~Point(); // явний виклик деструктора для 1 точки

	return 0;
}